/*
 * Security Compliance CLI - SSH Key Management
 * Copyright (C) 2025 Dynamic Devices Ltd
 * Licensed under GPLv3 - see LICENSE file for details
 */

use crate::communication::CommunicationChannel;
use crate::error::{Error, Result};
use base64::{engine::general_purpose, Engine as _};
use chrono::{DateTime, Duration, Utc};
use ed25519_dalek::SigningKey;
use rand::rngs::OsRng;
use std::fs;
use std::path::Path;
use tracing::{debug, info, warn};

/// Information about an installed SSH key
#[derive(Debug, Clone)]
pub struct InstalledKeyInfo {
    pub user: String,
    pub key_type: String,
    pub key_data: String,
    pub comment: String,
    pub line_number: usize,
    pub expiration: Option<chrono::DateTime<chrono::Utc>>,
    pub is_expired: bool,
    pub is_temp_key: bool,
}

#[derive(Debug, Clone)]
pub struct SshKeyPair {
    pub private_key: String,
    pub public_key: String,
    pub key_type: String,
    pub comment: String,
    pub expires_at: Option<DateTime<Utc>>,
}

#[derive(Debug)]
pub enum KeyRemovalCriteria {
    /// Remove a specific public key
    PublicKey(String),
    /// Remove all temporary keys generated by this tool
    TempKeys,
    /// Remove keys matching a pattern
    Pattern(String),
}

#[derive(Debug)]
pub struct SshKeyInstaller {
    pub target_user: String,
    pub test_connection: bool,
}

impl SshKeyInstaller {
    pub fn new(target_user: String, test_connection: bool) -> Self {
        Self {
            target_user,
            test_connection,
        }
    }

    /// Generate a new Ed25519 SSH key pair with optional expiration
    pub fn generate_key_pair(validity_hours: u32, comment: Option<String>) -> Result<SshKeyPair> {
        info!(
            "Generating new Ed25519 SSH key pair (valid for {} hours)",
            validity_hours
        );

        let mut csprng = OsRng {};
        let signing_key = SigningKey::generate(&mut csprng);
        let verifying_key = signing_key.verifying_key();

        // Extract private and public key bytes
        let private_key_bytes = signing_key.to_bytes();
        let public_key_bytes = verifying_key.to_bytes();

        // Format private key in OpenSSH format
        let private_key_b64 = general_purpose::STANDARD.encode(private_key_bytes);
        let public_key_b64 = general_purpose::STANDARD.encode(public_key_bytes);

        // Create comment with expiration info
        let expires_at = if validity_hours > 0 {
            Some(Utc::now() + Duration::hours(validity_hours as i64))
        } else {
            None
        };

        let comment = comment.unwrap_or_else(|| {
            format!(
                "security-compliance-cli-temp-key-{}",
                Utc::now().format("%Y%m%d-%H%M%S")
            )
        });

        let comment_with_expiry = if let Some(exp) = expires_at {
            format!(
                "{} expires:{}",
                comment,
                exp.format("%Y-%m-%d %H:%M:%S UTC")
            )
        } else {
            comment.clone()
        };

        // Format public key in OpenSSH format
        let public_key = format!("ssh-ed25519 {} {}", public_key_b64, comment_with_expiry);

        // Format private key in OpenSSH format (simplified)
        let private_key = format!(
            "-----BEGIN OPENSSH PRIVATE KEY-----\n{}\n-----END OPENSSH PRIVATE KEY-----",
            private_key_b64
        );

        Ok(SshKeyPair {
            private_key,
            public_key,
            key_type: "ssh-ed25519".to_string(),
            comment: comment_with_expiry,
            expires_at,
        })
    }

    /// Load an existing SSH public key from file
    pub fn load_public_key_from_file<P: AsRef<Path>>(path: P) -> Result<String> {
        let path = path.as_ref();
        info!("Loading SSH public key from: {}", path.display());

        let content = fs::read_to_string(path).map_err(Error::Io)?;

        let public_key = content.trim().to_string();

        // Basic validation - check if it looks like a valid SSH public key
        if !public_key.starts_with("ssh-") {
            return Err(Error::Config(format!(
                "Invalid SSH public key format in file: {}",
                path.display()
            )));
        }

        info!("Successfully loaded SSH public key");
        Ok(public_key)
    }

    /// Save private key to file with proper permissions
    pub fn save_private_key_to_file<P: AsRef<Path>>(private_key: &str, path: P) -> Result<()> {
        let path = path.as_ref();
        info!("Saving private key to: {}", path.display());

        fs::write(path, private_key).map_err(Error::Io)?;

        // Set restrictive permissions (600) on Unix systems
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(path).map_err(Error::Io)?.permissions();
            perms.set_mode(0o600);
            fs::set_permissions(path, perms).map_err(Error::Io)?;
        }

        info!("Private key saved with secure permissions");
        Ok(())
    }

    /// Install SSH public key on target device via communication channel
    pub async fn install_public_key(
        &self,
        channel: &mut dyn CommunicationChannel,
        public_key: &str,
    ) -> Result<()> {
        info!("Installing SSH public key for user: {}", self.target_user);

        // Detect current user if target_user is root (default)
        let actual_user = if self.target_user == "root" {
            match channel.execute_command("whoami").await {
                Ok(result) if result.exit_code == 0 => {
                    let detected_user = result.stdout.trim().lines().last().unwrap_or("").trim();
                    if !detected_user.is_empty()
                        && detected_user != "root"
                        && !detected_user.contains('@')
                    {
                        info!("Detected current user: {}, installing key for this user instead of root", detected_user);
                        detected_user.to_string()
                    } else {
                        info!("Could not parse user from whoami output: {:?}, using configured target: {}", result.stdout, self.target_user);
                        self.target_user.clone()
                    }
                }
                _ => {
                    info!(
                        "Could not detect current user, using configured target: {}",
                        self.target_user
                    );
                    self.target_user.clone()
                }
            }
        } else {
            self.target_user.clone()
        };

        // Determine home directory
        let home_dir = if actual_user == "root" {
            "/root".to_string()
        } else {
            format!("/home/{}", actual_user)
        };

        info!(
            "Installing SSH key for user: {} (home: {})",
            actual_user, home_dir
        );

        // Ensure the .ssh directory exists
        let create_ssh_dir = format!("mkdir -p {}/.ssh", home_dir);
        debug!("Creating .ssh directory: {}", create_ssh_dir);

        let result = channel.execute_command(&create_ssh_dir).await?;
        if result.exit_code != 0 {
            return Err(Error::Communication(format!(
                "Failed to create .ssh directory: {}",
                result.stderr
            )));
        }

        // Set proper permissions on .ssh directory
        let chmod_ssh_dir = format!("chmod 700 {}/.ssh", home_dir);
        debug!("Setting .ssh directory permissions: {}", chmod_ssh_dir);

        let result = channel.execute_command(&chmod_ssh_dir).await?;
        if result.exit_code != 0 {
            warn!(
                "Failed to set .ssh directory permissions: {}",
                result.stderr
            );
        }

        // Add the public key to authorized_keys (append to avoid overwriting)
        let authorized_keys_path = format!("{}/.ssh/authorized_keys", home_dir);
        let add_key_command = format!("echo '{}' >> {}", public_key.trim(), authorized_keys_path);

        debug!("Adding public key to authorized_keys");
        let result = channel.execute_command(&add_key_command).await?;
        if result.exit_code != 0 {
            return Err(Error::Communication(format!(
                "Failed to add public key to authorized_keys: {}",
                result.stderr
            )));
        }

        // Set proper permissions on authorized_keys
        let chmod_auth_keys = format!("chmod 600 {}", authorized_keys_path);
        debug!("Setting authorized_keys permissions: {}", chmod_auth_keys);

        let result = channel.execute_command(&chmod_auth_keys).await?;
        if result.exit_code != 0 {
            warn!(
                "Failed to set authorized_keys permissions: {}",
                result.stderr
            );
        }

        // Set ownership of the .ssh directory and files
        let chown_command = format!("chown -R {}:{} {}/.ssh", actual_user, actual_user, home_dir);
        debug!("Setting ownership: {}", chown_command);

        let result = channel.execute_command(&chown_command).await?;
        if result.exit_code != 0 {
            warn!("Failed to set ownership: {}", result.stderr);
        }

        info!(
            "SSH public key installed successfully for user: {}",
            actual_user
        );
        Ok(())
    }

    /// Test SSH connection using the installed key
    pub async fn test_ssh_connection(
        &self,
        host: &str,
        port: u16,
        private_key: &str,
    ) -> Result<()> {
        if !self.test_connection {
            debug!("SSH connection testing disabled");
            return Ok(());
        }

        info!("Testing SSH connection with installed key...");

        // Create a temporary file for the private key
        let temp_dir = tempfile::tempdir().map_err(Error::Io)?;
        let temp_key_path = temp_dir.path().join("temp_ssh_key");

        Self::save_private_key_to_file(private_key, &temp_key_path)?;

        // Try to connect using ssh2
        use ssh2::Session;
        use std::net::TcpStream;

        let tcp = TcpStream::connect(format!("{}:{}", host, port))
            .map_err(|e| Error::Communication(format!("TCP connection failed: {}", e)))?;

        let mut session = Session::new()
            .map_err(|e| Error::Communication(format!("SSH session creation failed: {}", e)))?;

        session.set_tcp_stream(tcp);
        session
            .handshake()
            .map_err(|e| Error::Communication(format!("SSH handshake failed: {}", e)))?;

        // Try to authenticate with the key
        session
            .userauth_pubkey_file(&self.target_user, None, &temp_key_path, None)
            .map_err(|e| Error::Communication(format!("SSH key authentication failed: {}", e)))?;

        if session.authenticated() {
            info!("‚úÖ SSH connection test successful!");
        } else {
            return Err(Error::Communication(
                "SSH authentication failed".to_string(),
            ));
        }

        Ok(())
    }

    /// Remove SSH public keys from target device
    pub async fn remove_public_keys(
        &self,
        channel: &mut dyn CommunicationChannel,
        removal_criteria: &KeyRemovalCriteria,
    ) -> Result<Vec<String>> {
        info!("Removing SSH public keys for user: {}", self.target_user);

        let authorized_keys_path = format!("/home/{}/.ssh/authorized_keys", self.target_user);

        // First, check if authorized_keys file exists
        let check_file_cmd = format!("test -f {}", authorized_keys_path);
        let result = channel.execute_command(&check_file_cmd).await?;
        if result.exit_code != 0 {
            info!("No authorized_keys file found - nothing to remove");
            return Ok(vec![]);
        }

        // Read current authorized_keys content
        let read_keys_cmd = format!("cat {}", authorized_keys_path);
        let result = channel.execute_command(&read_keys_cmd).await?;
        if result.exit_code != 0 {
            return Err(Error::Communication(format!(
                "Failed to read authorized_keys: {}",
                result.stderr
            )));
        }

        let current_keys = result.stdout;
        let mut removed_keys = Vec::new();
        let mut remaining_keys = Vec::new();

        // Process each line in authorized_keys
        for line in current_keys.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                remaining_keys.push(line.to_string());
                continue;
            }

            if self.should_remove_key(line, removal_criteria) {
                info!("Removing key: {}", self.truncate_key_for_display(line));
                removed_keys.push(line.to_string());
            } else {
                remaining_keys.push(line.to_string());
            }
        }

        if removed_keys.is_empty() {
            info!("No matching keys found to remove");
            return Ok(removed_keys);
        }

        // Write back the remaining keys
        let new_content = remaining_keys.join("\n");
        let write_keys_cmd = if new_content.trim().is_empty() {
            // If no keys remain, create empty file
            format!("echo -n > {}", authorized_keys_path)
        } else {
            // Write remaining keys
            format!(
                "cat > {} << 'EOF'\n{}\nEOF",
                authorized_keys_path, new_content
            )
        };

        debug!("Writing updated authorized_keys");
        let result = channel.execute_command(&write_keys_cmd).await?;
        if result.exit_code != 0 {
            return Err(Error::Communication(format!(
                "Failed to update authorized_keys: {}",
                result.stderr
            )));
        }

        // Set proper permissions
        let chmod_cmd = format!("chmod 600 {}", authorized_keys_path);
        let result = channel.execute_command(&chmod_cmd).await?;
        if result.exit_code != 0 {
            warn!(
                "Failed to set authorized_keys permissions: {}",
                result.stderr
            );
        }

        info!("Successfully removed {} SSH keys", removed_keys.len());
        Ok(removed_keys)
    }

    /// Check if a key should be removed based on criteria
    fn should_remove_key(&self, key_line: &str, criteria: &KeyRemovalCriteria) -> bool {
        match criteria {
            KeyRemovalCriteria::PublicKey(public_key) => {
                // Extract the key part (second field) for comparison
                let key_parts: Vec<&str> = key_line.split_whitespace().collect();
                let target_parts: Vec<&str> = public_key.split_whitespace().collect();

                if key_parts.len() >= 2 && target_parts.len() >= 2 {
                    key_parts[1] == target_parts[1] // Compare the base64 key part
                } else {
                    false
                }
            }
            KeyRemovalCriteria::TempKeys => key_line.contains("security-compliance-cli-temp-key"),
            KeyRemovalCriteria::Pattern(pattern) => self.matches_pattern(key_line, pattern),
        }
    }

    /// Check if key matches a wildcard pattern
    fn matches_pattern(&self, key_line: &str, pattern: &str) -> bool {
        // Simple wildcard matching for key comments
        if pattern.contains('*') {
            let pattern_parts: Vec<&str> = pattern.split('*').collect();
            if pattern_parts.len() == 2 {
                let prefix = pattern_parts[0];
                let suffix = pattern_parts[1];

                if prefix.is_empty() {
                    key_line.ends_with(suffix)
                } else if suffix.is_empty() {
                    key_line.contains(prefix)
                } else {
                    key_line.contains(prefix) && key_line.ends_with(suffix)
                }
            } else {
                // Multiple wildcards - use simple contains check
                pattern_parts.iter().all(|part| key_line.contains(part))
            }
        } else {
            key_line.contains(pattern)
        }
    }

    /// Truncate key for display purposes
    pub fn truncate_key_for_display(&self, key_line: &str) -> String {
        let parts: Vec<&str> = key_line.split_whitespace().collect();
        if parts.len() >= 3 {
            format!(
                "{}...{} {}",
                &parts[1][..8],
                &parts[1][parts[1].len() - 8..],
                parts[2]
            )
        } else if parts.len() >= 2 {
            format!("{}...{}", &parts[1][..8], &parts[1][parts[1].len() - 8..])
        } else {
            key_line.to_string()
        }
    }

    /// Detect temporary keys on the target device
    pub async fn detect_temp_keys(
        &self,
        channel: &mut dyn CommunicationChannel,
    ) -> Result<Vec<String>> {
        info!("Detecting temporary keys for user: {}", self.target_user);

        let authorized_keys_path = format!("/home/{}/.ssh/authorized_keys", self.target_user);

        // Check if authorized_keys file exists
        let check_file_cmd = format!("test -f {}", authorized_keys_path);
        let result = channel.execute_command(&check_file_cmd).await?;
        if result.exit_code != 0 {
            return Ok(vec![]);
        }

        // Search for temporary keys
        let search_cmd = format!(
            "grep -n 'security-compliance-cli-temp-key' {} || true",
            authorized_keys_path
        );
        let result = channel.execute_command(&search_cmd).await?;

        let mut temp_keys = Vec::new();
        for line in result.stdout.lines() {
            if !line.trim().is_empty() {
                // Remove line number prefix from grep output
                if let Some(colon_pos) = line.find(':') {
                    let key_line = &line[colon_pos + 1..];
                    temp_keys.push(key_line.to_string());
                }
            }
        }

        Ok(temp_keys)
    }

    /// Extract public key from private key file
    pub fn extract_public_key_from_private(private_key_path: &Path) -> Result<String> {
        info!(
            "Extracting public key from private key: {}",
            private_key_path.display()
        );

        // For Ed25519 keys, we need to read the private key and derive the public key
        let _private_key_content = fs::read_to_string(private_key_path).map_err(Error::Io)?;

        // This is a simplified approach - in a real implementation, you'd parse the OpenSSH private key format
        // For now, we'll return an error suggesting the user provide the public key directly
        Err(Error::Unsupported(
            "Extracting public key from private key file is not yet supported. Please use --public-key-file instead.".to_string()
        ))
    }
    pub async fn install_ssh_key_workflow(
        &self,
        channel: &mut dyn CommunicationChannel,
        public_key_file: Option<&Path>,
        validity_hours: u32,
        save_private_key_path: Option<&Path>,
        host: &str,
        port: u16,
    ) -> Result<SshKeyPair> {
        let key_pair = if let Some(pub_key_file) = public_key_file {
            // Load existing public key
            let public_key = Self::load_public_key_from_file(pub_key_file)?;

            // We don't have the private key, so create a placeholder
            SshKeyPair {
                private_key: String::new(), // Not available when loading from file
                public_key,
                key_type: "unknown".to_string(),
                comment: format!("loaded from {}", pub_key_file.display()),
                expires_at: None,
            }
        } else {
            // Generate new key pair
            Self::generate_key_pair(validity_hours, None)?
        };

        // Install the public key
        self.install_public_key(channel, &key_pair.public_key)
            .await?;

        // Save private key if requested and available
        if let Some(save_path) = save_private_key_path {
            if !key_pair.private_key.is_empty() {
                Self::save_private_key_to_file(&key_pair.private_key, save_path)?;
                info!("Private key saved to: {}", save_path.display());
            } else {
                warn!("Cannot save private key - not available when loading from public key file");
            }
        }

        // Test SSH connection if we have a private key
        if self.test_connection && !key_pair.private_key.is_empty() {
            if let Err(e) = self
                .test_ssh_connection(host, port, &key_pair.private_key)
                .await
            {
                warn!("SSH connection test failed: {}", e);
                warn!("Key was installed but connection test failed - you may need to check SSH server configuration");
            }
        }

        Ok(key_pair)
    }

    /// Check for installed SSH test keys on the target device
    pub async fn check_ssh_keys(
        channel: &mut dyn CommunicationChannel,
        target_user: Option<String>,
        detailed: bool,
        expired_only: bool,
        temp_keys_only: bool,
    ) -> Result<Vec<InstalledKeyInfo>> {
        info!("üîç Checking for installed SSH test keys...");

        // Detect current user if not specified
        let users_to_check = if let Some(user) = target_user {
            vec![user]
        } else {
            // Check current user and common locations
            let mut users = vec!["root".to_string()];
            match channel.execute_command("whoami").await {
                Ok(result) if result.exit_code == 0 => {
                    let detected_user = result.stdout.trim().lines().last().unwrap_or("").trim();
                    if !detected_user.is_empty()
                        && !detected_user.contains('@')
                        && detected_user != "root"
                    {
                        users.push(detected_user.to_string());
                    }
                }
                _ => {}
            }
            users
        };

        let mut all_keys = Vec::new();

        for user in users_to_check {
            let home_dir = if user == "root" {
                "/root".to_string()
            } else {
                format!("/home/{}", user)
            };

            let authorized_keys_path = format!("{}/.ssh/authorized_keys", home_dir);

            debug!(
                "Checking authorized_keys for user {}: {}",
                user, authorized_keys_path
            );

            // Check if authorized_keys file exists
            let check_command = format!(
                "test -f {} && echo 'exists' || echo 'not_found'",
                authorized_keys_path
            );
            match channel.execute_command(&check_command).await {
                Ok(result) if result.exit_code == 0 && result.stdout.contains("exists") => {
                    // Read the authorized_keys file
                    let cat_command = format!("cat {}", authorized_keys_path);
                    match channel.execute_command(&cat_command).await {
                        Ok(result) if result.exit_code == 0 => {
                            let keys = Self::parse_authorized_keys(
                                &result.stdout,
                                &user,
                                temp_keys_only,
                                expired_only,
                            );
                            all_keys.extend(keys);
                        }
                        Ok(result) => {
                            warn!("Failed to read {}: {}", authorized_keys_path, result.stderr);
                        }
                        Err(e) => {
                            warn!("Error reading {}: {}", authorized_keys_path, e);
                        }
                    }
                }
                _ => {
                    debug!("No authorized_keys file found for user: {}", user);
                }
            }
        }

        if all_keys.is_empty() {
            info!("No SSH keys found matching the criteria");
        } else {
            info!("Found {} SSH key(s)", all_keys.len());
            for key in &all_keys {
                Self::display_key_info(key, detailed);
            }
        }

        Ok(all_keys)
    }

    /// Parse authorized_keys content and extract key information
    fn parse_authorized_keys(
        content: &str,
        user: &str,
        temp_keys_only: bool,
        expired_only: bool,
    ) -> Vec<InstalledKeyInfo> {
        let mut keys = Vec::new();
        let now = chrono::Utc::now();

        for (line_num, line) in content.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let parts: Vec<&str> = line.splitn(3, ' ').collect();
            if parts.len() >= 2 {
                let key_type = parts[0];
                let key_data = parts[1];
                let comment = parts.get(2).unwrap_or(&"").to_string();

                // Filter for temp keys if requested
                if temp_keys_only && !comment.contains("security-compliance-cli-temp-key") {
                    continue;
                }

                // Parse expiration from comment if present
                let expiration = Self::parse_expiration_from_comment(&comment);
                let is_expired = expiration.is_some_and(|exp| now > exp);

                // Filter for expired keys if requested
                if expired_only && !is_expired {
                    continue;
                }

                let key_info = InstalledKeyInfo {
                    user: user.to_string(),
                    key_type: key_type.to_string(),
                    key_data: key_data.to_string(),
                    comment: comment.clone(),
                    line_number: line_num + 1,
                    expiration,
                    is_expired,
                    is_temp_key: comment.contains("security-compliance-cli-temp-key"),
                };

                keys.push(key_info);
            }
        }

        keys
    }

    /// Parse expiration timestamp from key comment
    fn parse_expiration_from_comment(comment: &str) -> Option<chrono::DateTime<chrono::Utc>> {
        if comment.contains("expires:") {
            // Look for pattern like "expires:2025-10-07 15:33:25 UTC"
            if let Some(expires_part) = comment.split("expires:").nth(1) {
                let timestamp_str = expires_part
                    .split_whitespace()
                    .take(3)
                    .collect::<Vec<_>>()
                    .join(" ");
                if let Ok(dt) =
                    chrono::DateTime::parse_from_str(&timestamp_str, "%Y-%m-%d %H:%M:%S UTC")
                {
                    return Some(dt.with_timezone(&chrono::Utc));
                }
            }
        }
        None
    }

    /// Display key information
    fn display_key_info(key: &InstalledKeyInfo, detailed: bool) {
        let status_icon = if key.is_expired {
            "‚ùå"
        } else if key.is_temp_key {
            "üîë"
        } else {
            "üóùÔ∏è"
        };

        let expiration_info = if let Some(exp) = key.expiration {
            if key.is_expired {
                format!(" (EXPIRED: {})", exp.format("%Y-%m-%d %H:%M:%S UTC"))
            } else {
                format!(" (expires: {})", exp.format("%Y-%m-%d %H:%M:%S UTC"))
            }
        } else {
            " (no expiration)".to_string()
        };

        info!(
            "{} User: {} | Type: {} | Line: {}{}",
            status_icon, key.user, key.key_type, key.line_number, expiration_info
        );

        if detailed {
            info!("   Comment: {}", key.comment);
            info!(
                "   Key: {}...{}",
                &key.key_data[..key.key_data.len().min(20)],
                &key.key_data[key.key_data.len().saturating_sub(20)..]
            );
        }

        if key.is_temp_key {
            if key.is_expired {
                warn!("   ‚ö†Ô∏è  This temporary test key has EXPIRED and should be removed!");
            } else {
                info!("   ‚ÑπÔ∏è  This is a temporary test key generated by security-compliance-cli");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_key_pair() {
        let key_pair = SshKeyInstaller::generate_key_pair(1, Some("test-key".to_string()))
            .expect("Should generate key pair");

        assert!(!key_pair.private_key.is_empty());
        assert!(!key_pair.public_key.is_empty());
        assert!(key_pair.public_key.starts_with("ssh-ed25519"));
        assert!(key_pair.comment.contains("test-key"));
        assert!(key_pair.expires_at.is_some());
    }

    #[test]
    fn test_generate_key_pair_no_expiry() {
        let key_pair =
            SshKeyInstaller::generate_key_pair(0, None).expect("Should generate key pair");

        assert!(key_pair.expires_at.is_none());
    }

    #[test]
    fn test_should_remove_key_temp_keys() {
        let installer = SshKeyInstaller::new("test".to_string(), false);
        let criteria = KeyRemovalCriteria::TempKeys;

        let temp_key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... security-compliance-cli-temp-key-20250107-143022 expires:2025-01-07 15:30:22 UTC";
        let regular_key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... user@hostname";

        assert!(installer.should_remove_key(temp_key, &criteria));
        assert!(!installer.should_remove_key(regular_key, &criteria));
    }

    #[test]
    fn test_should_remove_key_pattern() {
        let installer = SshKeyInstaller::new("test".to_string(), false);
        let criteria = KeyRemovalCriteria::Pattern("*temp*".to_string());

        let matching_key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... temp-key-123";
        let non_matching_key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... user@hostname";

        assert!(installer.should_remove_key(matching_key, &criteria));
        assert!(!installer.should_remove_key(non_matching_key, &criteria));
    }

    #[test]
    fn test_truncate_key_for_display() {
        let installer = SshKeyInstaller::new("test".to_string(), false);
        let key =
            "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 test-comment";

        let truncated = installer.truncate_key_for_display(key);
        assert!(truncated.contains("AAAAC3Nz"));
        assert!(truncated.contains("67890"));
        assert!(truncated.contains("test-comment"));
    }
}
